# Goo Semantic Analyzer

The semantic analyzer component is responsible for performing type checking and semantic validation on the abstract syntax tree (AST) generated by the parser.

## Components

The semantic analyzer consists of the following components:

- **Type Checker**: Verifies that operations are performed on compatible types
- **Symbol Table**: Manages scope and tracks symbols (variables, functions, types)
- **Error Reporting**: Provides detailed error messages for semantic issues

## Architecture

The semantic analyzer is implemented in Zig and follows the same modular architecture as other compiler components:

```
semantic/
  ├── zig/                  # Zig implementation
  │   ├── type_checker.zig  # Core type checker implementation
  │   ├── semantic.zig      # Main semantic analysis module
  │   ├── semantic_c_api.zig # C API wrapper
  │   ├── build.zig         # Build script
  │   ├── include/          # Public headers
  │   │   └── goo_semantic.h # C API header
  │   └── test_semantic.zig # Tests
  └── README.md             # This file
```

## Type System

The semantic analyzer implements a static type system for Goo, which includes:

- Primitive types: `void`, `bool`, `int`, `float`, `string`
- Composite types: arrays, structs, functions
- User-defined types

## Error Handling

Semantic errors are collected during analysis and can be retrieved through the API. Common error types include:

- Type mismatch
- Undefined variable/function/type
- Invalid assignment
- Invalid operation
- Invalid function call

## Integration

The semantic analyzer integrates with the compiler frontend through a C API defined in `goo_semantic.h`. This allows the analyzer to be used from both Zig and C code.

## Building and Testing

To build and test the semantic analyzer:

```bash
cd src/compiler/semantic/zig
./run_tests.sh
```

## Usage Example

```c
// Create parser and parse source
GooParserHandle parser = gooParserCreate();
gooParserParseString(parser, source_code);

// Create semantic analyzer
GooSemanticHandle semantic = gooSemanticCreate();

// Run semantic analysis
GooSemanticErrorCode result = gooSemanticAnalyze(semantic, parser);

// Check for errors
if (result != GOO_SEMANTIC_SUCCESS) {
    printf("Semantic error: %s\n", gooSemanticGetErrorMessage(semantic));
    
    int error_count = gooSemanticGetErrorCount(semantic);
    for (int i = 0; i < error_count; i++) {
        printf("  - %s\n", gooSemanticGetError(semantic, i));
    }
}

// Clean up
gooSemanticDestroy(semantic);
gooParserDestroy(parser);
```

## Future Enhancements

- More precise type inference
- Effect system for tracking side effects
- Ownership and borrowing analysis
- Constant folding and evaluation 